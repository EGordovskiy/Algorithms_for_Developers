"""
Посылка 64857059

Спринт 6. Задача B. Железные дороги

В рамках данной задачи необходимо реализовать алгоритм определения оптимальности карты железных дорог
между городами.


--ПРИНЦИП РАБОТЫ--

За основу определения оптимальности (или же не оптимальности в противном случае) взят алгоритм поиска в
глубину DFS с определением наличия (отсутствия) цикла в графе.
В начале функцию read_input() обрабатываем входные данные: создаем граф карты железных дорог с учетом
направления движения (ширины полотен в нашем случае) железных дорог между городами (вершинами) для
дальнейшей работы. В итоге получаем ориентированный граф и количество городов.

С помощью функции is_optimal_railways() определяем истинность утверждения оптимальности карты железных дорог.
Для удобства определения уже посещенных городов (вершин) создаем отедельный "цветовой" массив color, где будем
помечать вершины тремя цветами: белый (не посещенный город), серый (уже посещенный, но не все его ребра
обработаны) и черный (город уже посещен и все его ребра обработаны).
Таким образом, если при обходе графа в процессе обхода в глубину мы наткнемся на город, помеченный серым цветом,
это означает, что в графе есть цикл. Это означает, что существует пара городов, между которыми есть маршрут
с разным типом дорог и карта железных дорог в этом случае является не оптимальной. Функция возвращает при этом
значение False, что в итоге при обработке результата приведет к печати ответа "NO".
В противном случае, мы пройдем весь граф, циклов не обнаружим, вернем истинное значение и напечатаем "YES".
Это будет означать, что данная карта железных дорог является оптимальной.


--ВРЕМЕННАЯ СЛОЖНОСТЬ--

В нашем случае для прохождения всего графа в глубину необходимо пройти по всем вершинам графа. Это означает,
что сложность будет O(V). При этом нужно обходить все ребра графа, что в итоге в худшем случае дает сложность
O(V + E).
В лучшем же случае, цикл мы обнаружем уже на второй итерации и сложность составит O(V).


--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--

В нашем случае мы задействуем дополнительную память для хранения массива цветов, что означает O(V).
Помимо этого так же необходимо использовать стек для хранения вершин, что тоже означает O(V).
В итоге получаем пространственную сложность равную O(V + V).
"""


def read_input():
    cnt_city = int(input())
    graph = [[] for _ in range(cnt_city)]
    for i in range(cnt_city - 1):
        arr = input()
        for j in range(len(arr)):
            if arr[j] == 'R':
                graph[i].append(i + j + 1)
            else:
                graph[i + j + 1].append(i)
    return graph, cnt_city


WHITE = 0
GRAY = 1
BLACK = 2


def is_optimal_railways(graph, cnt_city):
    color = [WHITE] * cnt_city
    for i in range(cnt_city):
        stack = [i]
        while stack:
            vertex = stack.pop()
            if color[vertex] == WHITE:
                color[vertex] = GRAY
                stack.append(vertex)
                for edge in graph[vertex]:
                    if color[edge] == WHITE:
                        stack.append(edge)
                    elif color[edge] == GRAY:
                        return False
            elif color[vertex] == GRAY:
                color[vertex] = BLACK
    return True


if __name__ == '__main__':
    graph, cnt_city = read_input()
    if is_optimal_railways(graph, cnt_city):
        print('YES')
    else:
        print('NO')
