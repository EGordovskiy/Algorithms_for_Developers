"""
Посылка 64883122

Спринт 6. Задача A. Дорогая сеть

В рамках данной задачи необходимо реализовать максимальное остовное дерево в неориентированном графе,
который задаёт схему офиса. Решение данной задачи основано на алгоритме Прима для поиска минимального
остовного дерева с некоторыми изменениями.


--ПРИНЦИП РАБОТЫ--

Для суммирования ребер максимального остовного дерева завели переменную maximum_spanning_tree, к которой
будет суммировать значения весов ребер.
Так же задали следующие вспомогательные данные:
added = set() - множество вершин, уже добавленных в остов;
edges = [] - массив рёбер, исходящих из остовного дерева.

Функция add_vertex() служит для добавления вершины в остов. При этом проводится проверка исходящих ребер
данной вершины на отсутствие этих ребер (вершин ребра) в множестве вершин, добавленных в остов.
В этом случае эти вершины добавляются в массив ребер, исходящих из остовного дерева посредство функции heapq,
с целью преобразования edges в кучу для использования пирамидальной сортировки min_heap, при этом в данный
массив добавляем вес ребра с отрицательным значением для нужного нам результата сортировки.
То есть в начале списка будут лежать не минимальные значения, а максимальные.

Непосредственно реализована функция find_MST() для поиска максимального остовного дерева. На вход передаем
граф. В самом начале определяемся с тем, что будем начинать обходить граф с 1-ой вершины.
Далее циклом, пока длина множества added не равна значению вершин в графе и массив (куча)  существуют
(имеет элементы), берем "минимальный" (в нашем случае максимальный) элемент из кучи edges (то есть берем и удаляем).
Проверяем, что вершины этого ребра нет во множестве вершин, добавленных в остов и, в таком случае, к значению
максимального остовного дерева maximum_spanning_tree прибавляем вес максимального ребра, как раз того, что мы
забарали из кучи. После чего вызваем функцию add_vertex() для добавления данной вершины в остов.
Когда цикл завершится, необходимо проверить, что длина множества added равно количеству вершин графа.
В этом случае вернем значение maximum_spanning_tree, что и будет передавать значение максимального остовного дерева.
В противном случае, если в графе несколько компонент связности, выведем сообщение: 'Oops! I did it again'.


--ВРЕМЕННАЯ СЛОЖНОСТЬ--

В рамках реализации нашего алгоритма мы использовали приоритетную очередь. Это говорит о том, что
для поиска минимального (в нашем случае максимального элемента) мы затрачиваем О(logV) времени, где V - количество
вершнин в графе.
Таким образом если вместе с ребром в подграф добавляется новая вершина, то это ребро добавляется в остов.
Если ребро соединяет две вершины, уже присутствующее в подмножестве остова, мы отбрасываем его из дальнейшего
рассмотрения и из кучи в том числе.
В общем случае временная сложность алгоритма получается O(E*logV), где E - количество ребер графа.
В случае применения алгоритма Прима на основе массива программе требуется количество шагор пропорциональное
количеству вершин. При этом на каждом шаге мы находим минимальное (максимальное) по весу ребро. В худшем случае
для поиска минимлаьного (максимального) по весу ребра нам придется перебрать все ребра.
В этом случае временная сложность составит уже O(E + V).



--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--

Нам необходимо будет хранить в памяти множество вершин в остове, которе к концу работы алгоритма заполнится и будет
О(V). Так же необходимо хранить значения ребер E. Это означает, что по памяти сложность будет O(V + E).
"""
import heapq


def read_input():
    tops, edges = map(int, input().split())
    graph = {i + 1: [] for i in range(tops)}
    for _ in range(edges):
        top_from, top_to, weight = map(int, input().split())
        inter_one = (top_to, weight)
        inter_two = (top_from, weight)
        graph[top_from].append(inter_one)
        graph[top_to].append(inter_two)
    return tops, graph


def add_vertex(v, ed, added):
    added.add(v)

    for i in ed:
        if i[0] not in added:
            heapq.heappush(edges, (-i[1], i[0]))


def find_MST(graph, added):
    maximum_spanning_tree = 0
    top = 1
    ed = graph[top]
    add_vertex(top, ed, added)

    while len(added) != tops and edges:
        extract = heapq.heappop(edges)
        if extract[1] not in added:
            maximum_spanning_tree += abs(extract[0])
            add_vertex(extract[1], graph[extract[1]], added)

    if len(added) != tops:
        return None
    else:
        return maximum_spanning_tree


if __name__ == '__main__':
    tops, graph = read_input()
    added = set()
    edges = []
    result = find_MST(graph, added)
    if result is None:
        print('Oops! I did it again')
    else:
        print(result)
