"""
Посылка 65471863

Спринт 8. Задача B. Шпаргалка

В рамках данной задачи необходимо реализовать алгоритм проверки возможности разбиения слова на
слова (группу слов), которые даны в во входных данных.


--ПРИНЦИП РАБОТЫ--

В рамках данной реализации сначала создадим префиксное дерево, где вершины дерева будем хранить
в словаре. Терминальные узлы будем отмечать длиной самого слова, чтобы использовать их
в дальнейшем.
После префиксного дерева создадим массив, куда будем записывать промежуточные значения, можно ли
создать строку с данным индексом или же нет. В самом начале массива в нулевом индексе располагается
пустая строка, поэтому мы можем записать для нее положительное значение.
Далее для каждого индекса будем проходить по префиксному дереву до тех пор, пока не привысим длину
строки или же пока строка совпадает. Когда мы встречаем терминальный узел и при этом, ответ положительный
и для строки без текущего рассматриваемого слова, тогда записываем в массив положительный
ответ. В противном случае записывается отрицательный ответ.


--ВРЕМЕННАЯ СЛОЖНОСТЬ--

Для создания префиксного дерева временная сложность составит O(k), где k - суммарная длина
всех слов во множестве.
Так же для прохождения по префиксному дереву нам потребуется O(n), где n - количество
символов в строке. В лучшем случае, мы закончим итерацию сразу же. В худшем же
случае, необходимо будет пройти по всему дереву, что означает O(n), где n - размер дерева.
Иными словами сложность будет O(n^2).
Таким образом:
в худшем случае, временная сложность составит O(n^2 + k), или O(n^2);
в лучшем случае - O(n + k), или O(n).


--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--

Для хранения дерева мы будем сохранять три значения, значение узла, словарь и терминальное
значение.
В лучшем случае, если все слова имеют один корень, получим O(n * 3), где n — суммарная длина
всех слов во множестве. В худщем случае, если все слова имеют разные корни, получаем
O(n * k * 3), где n — количество слов, а k — средняя длина слов.
Кроме того нам нам потребуется хранить массив с промежуточными решениями для каждого
индекса O(l), где l — количество символов в строке.
Помимо этого, нам необходимо хранить два индекса и ссылку на следующий узел, что означает O(3).
Таким образом:
в худшем случае пространственная сложность составит O(n * k * 3 + l + 3), или O(n);
в лучшем случае - O(n * 3 + l + 3), или O(n).
"""


class Node:
    def __init__(self, value, next=None):
        self.value = value
        self.next = {} if next is None else next
        self.terminale = False


def create_tree(words):
    root = Node('')
    for word in words:
        node = root
        for index, symbol in enumerate(word):
            new_node = Node(symbol)
            node.next[symbol] = node.next.get(symbol, new_node)
            if index == len(word) - 1:
                node.next[symbol].terminale = len(word)
            node = node.next[symbol]
    return root


def is_split_words(string, words):
    root = create_tree(words)
    len_string = len(string)
    dp = [False for _ in range(len_string + 1)]
    dp[0] = True
    node = root
    for i in range(len_string):
        offset = 0
        while i + offset < len_string + 1:
            if node.terminale and dp[i + offset - node.terminale]:
                dp[i + offset] = True
            if (i + offset == len(string) or not node.next.get(string[i + offset], False)):
                node = root
                break
            node = node.next[string[i + offset]]
            offset += 1
    return dp[-1]


if __name__ == '__main__':
    inp_string = input()
    count_words = int(input())
    inp_words = [input() for _ in range(count_words)]
    if is_split_words(inp_string, inp_words):
        print('YES')
    else:
        print('NO')
