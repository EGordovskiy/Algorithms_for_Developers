"""
Посылка 65475944

Спринт 8. Задача А. Packed Prefix

В рамках данной задачи необходимо реализовать алгоритм поиска наибольшего общего префикса
для всех распакованных строк.


--ПРИНЦИП РАБОТЫ--


Сначала необходимо распаковать (конвертировать) значения входных строк в читаемый вид набор буквенных
символов. По заданию необходимо распаковывать строки исходя из следующих правил. Если зашифрованной
строке встречаем буквенный символ, перед которым не было ни чисел ни скобок, тогда сразу этот символ
записываем в общий результат расшифрованной строки. Если встречается число, тогда записываем это число
в стек множителя, если встречаем открывающую скобку, тогда все символы в скобке записываем в стек к
символам. Если встречается закрывающая скобка, тогда последние символы из стека умножаем на последнее
число из стека с множителем. Если в стеке с символами не осталось больше слов, тогда полученное слово
добавим в результат. Если в стеке с символами остались слова, тогда полученное слово добавим в стек.
Поиск общего максимального префикса будем осуществлять следующим образом. Для начала найдем самое
маленькое слово в списке. Далее пройдемся по всем символам строки последовательно и будем сравнивать
с символами в других строках на тех же местах. Как только получим расхождением, найдется и индекс конца
префикса.


--ВРЕМЕННАЯ СЛОЖНОСТЬ--


Если учитывать распаковку всех строк в массиве n, с значением элементов n в каждой строке, мы получим
в лучшем случае, если строк в массиве одна: O(n). Если строк больше, тогда получим O(n^2).
Так же нам необходимо провести поиск минимальной строки в массиве k, в лучшем случае, если элементов
в массиве 1, получим O(1), в худшем случае пройдем по всем элементам O(k).
Так же для сравнения необходимо пройти по всем строкам массива в худшем случае O(n^2). В лучшем, если
одна строка в массиве, сразу же выведем ее в рузультат O(1).
Таким образом в худшем случае значение временной сложности будет O(n^2 + k + n^2) или O(n^2).
В лушем же случае получим значение O(n).

--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--

Нам необходимо будет хранить n распакованных элементов, что означаем O(n) в худшем случае и O(1)
в лучшем, если строка всего одна. Так же необходимо хранить значение минимального индекса и один
символ, что означает O(2).
Таким образом общая пространственная сложность в худшем случае составит O(n + 2) или O(n).
В лучшем случае она будет константной O(1).
"""


def convert(string):
    multiply = []
    symbol = []
    result = []
    for char in string:
        if char.isnumeric():
            multiply.append(int(char))
            continue
        if char == '[':
            symbol.append([])
            continue
        if char == ']':
            if len(symbol) == 1:
                result.append(''.join(symbol.pop()) * multiply.pop())
                continue
            previous = ''.join(symbol.pop())
            symbol[-1].append(previous * multiply.pop())
            continue
        if len(symbol) == 0:
            result.append(char)
            continue
        symbol[-1].append(char)
    return ''.join(result)


def convert_all(strings):
    convert_res = []
    for i in strings:
        convert_res.append(convert(i))
    return convert_res


def find_max_prefix(mass_strings):
    strings = convert_all(mass_strings)
    if len(strings) == 1:
        return strings[0]
    min_index = 0
    len_strings = len(strings)
    for i in range(1, len_strings):
        if len(strings[min_index]) > len(strings[i]):
            min_index = i
    len_index = len(strings[min_index])
    for ind in range(len_index):
        symbol = strings[0][ind]
        for string in strings[1:]:
            if symbol != string[ind]:
                return string[:ind]
    return strings[min_index]


if __name__ == '__main__':
    quantity_strings = int(input())
    mass_strings = [input() for _ in range(quantity_strings)]
    print(find_max_prefix(mass_strings))
