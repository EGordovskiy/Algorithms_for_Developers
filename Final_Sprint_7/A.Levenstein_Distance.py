"""
Посылка 65145501

Спринт 7. Задача A. Расстояние по Левенштейну

В рамках данной задачи необходимо реализовать алгоритм поиска разницы между двумя строками по принципу
Левенштайна. Это значит, что нужно найти разницу атомарных изменений, с помощью которых можно одну строку
превратить в другую.


--ПРИНЦИП РАБОТЫ--

На вход функции find_levenshtein() поиска расстояния Левенштайна подается два аргумента: первая и вторая
строки, между которыми нужно найти разницу.
Для начала мы найдем значения длин данных строк, чтобы найти из них меньшую по длине. Это необходимо для
того, чтобы использовать массив наименьшей длины в дальнейших вычислениях.
Так как нулевой ряд матрицы – просто восходящая последовательность, следует, что, чтобы из пустой строки
получить любую непустую, нужно ровно то число вставок, сколько символов в непустой строке.
И наоборот: n удалений из строки длины n приведут неизбежно к пустой строке.
Далее мы двигаемся по рядам матрицы, используем только текущий ряд и предыдущий, таким образом заполняем
неизвестные (пустые) клетки текущего ряда. Соседние ячейки отвечают за вставку одного символа, удаление
или же его замену (в случае, если символы не равны).
Из трех возможных изменений мы выбираем то, что имеет меньшее значение. Таким образом раз за разом
мы проходим по всем элементам и заполняем значения матрицы.
После всех изысканий в качестве ответа используется значение последней ячейки массива с текущими
значениями.


--ВРЕМЕННАЯ СЛОЖНОСТЬ--

В худшем, среднем и лучшем случаях временная сложность составит O(N * M).
Где N — длина одной строки, а M — длина другой строки


--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--

В нашем случае мы используем массивы размером N - длина наименьшей строки.
Таким образом пространственная сложность составит O(N).
"""


def read_input():
    first_str = input()
    second_str = input()
    return first_str, second_str


def find_levenshtein(str_a, str_b):
    n, m = len(str_a), len(str_b)
    if n > m:
        str_a, str_b = str_b, str_a
        n, m = m, n
    current_row = [i for i in range(n + 1)]
    for i in range(1, m + 1):
        previous_row, current_row = current_row, [i] + [0] * n
        for j in range(1, n + 1):
            change = previous_row[j - 1]
            if str_a[j - 1] != str_b[i - 1]:
                change += 1
            current_row[j] = min(previous_row[j] + 1, current_row[j - 1] + 1, change)
    return current_row[n]


if __name__ == '__main__':
    first_str, second_str = read_input()
    print(find_levenshtein(first_str, second_str))
