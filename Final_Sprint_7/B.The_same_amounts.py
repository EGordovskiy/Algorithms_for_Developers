"""
Посылка 65164278

Спринт 7. Задача B. Одинаковые суммы

В рамках данной задачи необходимо реализовать алгоритм поиска ответа, можно ли разбить массив данных
на две части так, чтобы сумма в них была одинаковой.


--ПРИНЦИП РАБОТЫ--

Для начала можно проверить, что сумма всех элементов может быть поделена пополам. В таком случае существует
вероятность, что массив можно разбить на два массива с равными суммами. В противном случае, если сумма не
четная, можно сразу сказать, что данный массив нельзя разбить на два массива с равной суммой.
Для пустого множества можно получить только ноль. Далее перебирая все элементы и учитывая значения данного
и предыдущего элемента массива можно получить все варианты сумм. Но так как нам нужно получить только
половину от суммы элементов массива, то есть, если какая-та часть элементов в совокупности дает половину
значения суммы всего массива, то данный массив можно разделить на два равных по сумме массива.


--ВРЕМЕННАЯ СЛОЖНОСТЬ--

В лучшем случае при обходе всех элементов массива, если первый элемент массива будет равен половине
суммы массива, временная сложность составит O(1).
В худшем случае при обходе всех элементов массива N, и половины суммы массива S, получим значение
временной сложности равное O(N*(S/2)). Или O(N*S).


--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--

В данном случае нам необходимо хранить массив, равный половине суммы всего массива.
Это означает, что пространственная сложность зависит от размера суммы и составляет O(S).
"""
from typing import List, Tuple


def read_input() -> Tuple[int, List[int]]:
    cnt_elem = int(input())
    mass_elems = list(map(int, input().split()))
    return cnt_elem, mass_elems


def is_identical_summs(cnt_elem: int, mass_elems: List[int]) -> bool:
    sum_elems = sum(mass_elems)
    if sum_elems % 2 != 0:
        return False
    half_sum = sum_elems // 2
    dp: List[bool] = [False] * (half_sum + 1)
    dp[0] = True
    for i in range(1, cnt_elem + 1):
        for j in range(half_sum, mass_elems[i - 1] - 1, -1):
            dp[j] = dp[j - mass_elems[i - 1]] or dp[j]
            if j == half_sum and dp[j]:
                return True
    return dp[-1]


if __name__ == '__main__':
    cnt_elem, mass_elems = read_input()
    print(is_identical_summs(cnt_elem, mass_elems))
