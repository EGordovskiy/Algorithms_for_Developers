"""
Посылка 63534349

Спринт 5. Задача A. Пирамидальная сортировка

В рамках данной задачи необходимо реализовать сортировку кучей для входных данных, в которых используется
информацию о логине пользователя, количестве решенных задач и количестве ошибок (штрафов), полученных
при решении задач. Пирамидальная сортировка проводится в первую очередь по количеству задач (больше - лучше),
потом по количеству ошибок (меньше - лучше), в случае совпадения первых двух параметров, по логину в
лексикографическом порядке.


--ПРИНЦИП РАБОТЫ--

В рамках решения задачи реализована функция обработки входных данных read_input(). Которая получает
на вход данные в качестве количества строк и сами строки с указанием уникального логина,
количества решенных задач и количества ошибок (штрафов), полученных при решении задач, и выглядят так:
"alla 4 100".
Исходя из условий задачи необходимо проводить сортировку в зависимости от количества решенных задач,
штрафов и логина пользователя, поэтому входные данные строк преобразуются в кортежи вида:
(-4, 100, 'alla').
Для удобства функция обработки входных данных возвращает размер (длину) массива, и сам массив кортежей
с учетом удобства реализации сравнения элементов этого массива друг с другом.

Для реализации пирамидальной сортировки создадим вспомогательную функцию heapify().
Функция необходимо для реализации создания бинарной кучи из элементов массива для дальнейшей ее
сортировки и проверки, что на вершине (в корне) кучи всегда максимальный элемент.

В рамках реализации функции heap_sort() происходит постоянное преобразование кучи с выводом
максимального элемента вверх (корень) кучи, с последующим перемещением максимального элемента
в конец кучи (списка), после чего этот элемент больше не участвует в перестроении кучи.
Далее процесс повторяется снова: определяется максимальный элемент кучи, который в последствии
перемещается перед последним элементом списка (предпоследним).
Процесс происходит до тех пор, пока все элементы кучи таким образом не будут перебраны и в результате
получится отсортированный список и все вершины кучи не будут удалены.


--ВРЕМЕННАЯ СЛОЖНОСТЬ--

В случае пирамидальной сортировки можно сказать, что во всех случаях (худшем, среднем, лучшем)
временная сложность алгоритма будет постоянной и она равна O(n*logn). Таким образом, если
в рамках условия задачи нам необходимо стабильно получить результат за O(n*logn), то
целесообразно будет использовать пирамидальную сортировку.


--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--

В рамках реализации данного алгоритма не используется дополнительной памяти и, если не брать
в расчет входные данные, можно придти к выводу, что пространственная сложность алгоритма является
константной величиной, таким образом O(1).
"""


def read_input():
    n = int(input())
    input_arr = []
    for _ in range(n):
        name, tasks, fails = input().split()
        input_arr.append((-(int(tasks)), int(fails), name))
    return n, input_arr


def heapify(arr, heap_size, root_index):
    largest = root_index
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2

    if left_child < heap_size and arr[left_child] > arr[largest]:
        largest = left_child

    if right_child < heap_size and arr[right_child] > arr[largest]:
        largest = right_child

    if largest != root_index:
        arr[root_index], arr[largest] = arr[largest], arr[root_index]
        heapify(arr, heap_size, largest)


def heap_sort(arr, heap_size):
    for index in range(heap_size, -1, -1):
        heapify(arr, heap_size, index)

    for index in range(heap_size - 1, 0, -1):
        arr[index], arr[0] = arr[0], arr[index]
        heapify(arr, index, 0)


if __name__ == '__main__':
    n, arr = read_input()
    heap_sort(arr, n)
    for i in arr:
        print(i[-1])
