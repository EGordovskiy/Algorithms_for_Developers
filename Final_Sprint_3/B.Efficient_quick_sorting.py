"""
Посылка 58044769

Спринт 3. Задача В. Эффективная быстрая сортировка

По условиям задачи необходимо было реализовать алгоритм быстрой сортировки методом in-place - без
использования дополнительной памяти и работой только с данными входного массива.

--ПРИНЦИП РАБОТЫ--

Как и было указано раньше, при реализации задачи необходимо было использовать метод in-place - без
использования дополнительной памяти.
В целом в реализации алгоритма используется несколько функций. Первая функция read_input()
необходима для обработки входных данных. В результате работы функции возвращается массив, который
содержит в себе обработанные данные в виде кортежей. Пример массива: [(-4, 100, 'alla'), (-6, 1000, 'gena')].
То есть мы заранее обрабатываем входные данные так, чтобы в будущем их было легче сравнивать между собой.
То есть нулевой элемент именно кортежа указывает на количество решенных задач, первый - на количество штрафов,
второй - имея участника соревнования.

В функции quick_sort() реализуем рекурсивный вызов для разных отрезков массива.
При первом вызове функции заданы значения left=0 и right=None по умолчанию. Далее идет
проверка для значения right является ли оно None и переопределяем его равным длине массива arr минут
единица.
Так же проверяем разницу между крайним правым и левым значением, то есть right - left < 1, и в этом
случае возвращаем значение None.

Определяем переменную i через вызов функции in_place(). Получив значение i, рекурсивно перевызываем функцию
quick_sort() для разных диапазонов массива в том числе и в зависимости от результатов рекурсивных вызовов
функции quick_sort().

В функции partition() реализуем конкретно сортировку без использования дополнительной памяти методом in-place.
На вход функции получаем сам массив, значения левого и правого края массива.
Определяем значение ind_pivot (индекс опорного элемента), как правый элемент минус 1,
то есть ind_pivot = right - 1.
Сразу при реализации функции меняем местами элемент массива с индексом left с элементом с индексом ind_pivot.
Далее определяем переменную pivot значением элмента arr[left].
Создамем счетчики i и j для того, чтобы пройти по всему массиву.
Циклом проходим по всему массиву с крайнего левого элемента + 1 до крайнего правого. При этом при каждой
итерации счетчик j растет на единицу.
При этом в цикле проверяем условие arr[j] <= pivot, если это так, меняем местами элементы arr[j], arr[i]
местами, а так же счетик i увеличиваем на единицу.
Этим самым мы реализуем возможность в рамках цилка в конец массива переместить элемент массива с "худшими"
данными участника.
После цикла возвращаем на предпоследнее место значение элемента pivot (меняем местами), то есть
arr[left], arr[i - 1]. И возвращаем значение i - 1, для проведения дальнейшей сортировки и рекурсивного вызова
функции quick_sort().

Как результат мы постепенно проходим по всему массиву и сверяемся с элементом pivot и делаем перестановки в
зависимости от сравнений. Постоянно укладывая в конец массива "худшие" элементы массива.


--ВРЕМЕННАЯ СЛОЖНОСТЬ--

В данной задаче реализован алгоритм быстрой сортировки, а это значит, что временная сложность в лучшем случае
составляет О(nlog n).
Стоит отметить, что в худшем случае алгоритм будет работать за O(n^2). Худший случай возможен при условии, что
в качестве опорного элемента был выбран самый большой или же самый маленький элемент. В том числе имеет значение,
если сортируется уже отсортированный массив. То есть killer-последовательностью для алгоритма быстрой
сортировки будет случай, когда в уже отсортированном массиве в качестве опорного элемента взят самый большой
или же самый маленький элемент.


--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--

В рамках задачи реализован алгоритм быстрой сортировки методом in-place, это означает, что
пространственная сложность в лучшем случае составит O(nlog n), в худшем же случае она уже
составит О(n), что в случае рекурсивных вызовов может привести к переполнению стека.
"""
def read_input():
    n = int(input())
    arr = []
    for i in range(n):
        name, tasks, fails = input().split()
        arr.append((-(int(tasks)), int(fails), name))
    return arr


def partition(arr, left, right):
    ind_pivot = right - 1
    arr[left], arr[ind_pivot] = arr[ind_pivot], arr[left]
    pivot = arr[left]
    i = left + 1
    j = left + 1

    while j <= right:
        if arr[j] <= pivot:
            arr[j], arr[i] = arr[i], arr[j]
            i += 1
        j += 1

    arr[left], arr[i - 1] = arr[i - 1], arr[left]
    return i - 1


def quick_sort(arr, left=0, right=None):
    if right is None:
        right = len(arr) - 1

    if right - left < 1:
        return

    i = partition(arr, left, right)
    quick_sort(arr, left, i - 1)
    quick_sort(arr, i + 1, right)


if __name__ == '__main__':
    arr = read_input()
    quick_sort(arr)
    for i in range(len(arr)):
        print(arr[i][-1])
