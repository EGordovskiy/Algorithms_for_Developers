"""
Посылка 58044227

Спринт 3. Задача А. Поиск в сломанном массиве

По условиям задачи необходимо было реализовать алгоритм поиска нужного элемента в
сломанном массиве. Сдать решение необходимо было реализовав только функцию поиска.
Обрабатывать ввод и вывод данных было не нужно.


--ПРИНЦИП РАБОТЫ--

В качестве аргументов на вход функции подаются только сломанный массив nums и искомый элемент target.
Далее в ходе реализации функции нам понадобятся две переменных left и right, кторые служат
для обозначения границ массива на входе. Соответственно left - это крайний левый (нулевой) индекс массива,
а right - последний индекс массива, обозначается, как длина массива минус 1.

Сам поиск искомого элемента основан на алгоритме бинарного поиска и некоторым образом
доработан под входные данные, исходя из условия, что массив отсортирован, но сломан.
Схема алгоритма данного бинарного поиска заключается в следующем.
Первым делом мы проверяем, что значение правого края границы массива больше
либо равна значению левого, иначе цикл прекращается. Это условие выхода из цикла.

Если условия цикла выполняются, мы определяем значение среднего индекса массива, по формуле
mid = left + (right - left) // 2.
После этого проверяем, не является ли искомый элемент (не равен ли он) значению среднего элемента nums[mid].
И если это условие верно, функция возвращает значение среднего индекса mid. Это и есть результат поиска в
сломанном массиве.

Если это условие не выполняется, тогда продолжаем дальше: мы проводим первое сравнение "1", то есть
проверяем условие, что средний элемент меньше крайнего правого элемента. В этом случае мы понимаем,
что на данном участе массива у нас не сломанный участок, а упорядоченный кусок массива.
Далее мы проверяем следующее условие, что искомое значение item больше среднего и меньше либо равно
крайнему правому значению массива, в этом случае сдвигаем границы поиска элемента и переприсваиваем
значение left среднему индексу + 1 (left = mid + 1), так как средний элемент мы уже проверили.
Иначе, если условие nums[mid] < target <= nums[right] не верно, мы сдвигаем границу поиска и переприсваиваем
значение right = mid - 1 (значение mid мы уже проверяли и можно задействовать уже предыдущий элемент массива).

Иначе если условие "1" не верно, мы проводим следующее сравнение.
Проверяем, что искомый элемент лежит в пределах равным или большим левого края и меньше
среднего значения, то есть nums[left] <= target < nums[mid]. Если так, то сдвигаем границу right = mid - 1.
Если иначе, то сдвигаем границу left = mid + 1.
Далее уже исходя из новых пределов границ выполняем следующую итерацию цикла. И так пока, мы не найдем
искомый элемент и вернем индекс, где этот элемент находится в массиве, и алгоритм завершится.
Иначе, если цикл был завершен и нужный элемент не был найдем, функция возвращает значение - 1.
После этого алгоритм завершается.


--ВРЕМЕННАЯ СЛОЖНОСТЬ--

В рамках реализации алгоритма задействован цикл, но нам удалось применить принцип бинарного поиска,
таким образом общая временная сложность составляет О(log n).


--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--

Общая пространственная сложность данного алгоритма является константной и составляет О(1).

"""
def broken_search(nums, target) -> int:
    left = 0
    right = len(nums) - 1
    while right >= left:
        mid = left + (right - left) // 2
        if target == nums[mid]:
            return mid
        if nums[mid] < nums[right]:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
        else:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
    return - 1


def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6
